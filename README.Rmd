---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# gridburn

<!-- badges: start -->
<!-- badges: end -->

Sparse polygon rasterization with exact coverage fractions.

`gridburn` computes exact fractional coverage for polygon-grid intersections
and returns results in a compact sparse format — not a dense matrix. The
algorithm is vendored from [exactextract](https://github.com/isciences/exactextract) C++ library (the
same code behind [exactextractr](https://github.com/isciences/exactextractr)).

## Installation

```r
# install.packages("pak")
pak::pak("hypertidy/gridburn")
```

Requires [libgeos](https://github.com/paleolimbot/libgeos) and
[cpp11](https://cpp11.r-lib.org/) (installed automatically as dependencies).

## Usage

```r
library(gridburn)
library(geos)

# A polygon that partially covers a 10x10 grid
poly <- as_geos_geometry(
  "POLYGON ((1.5 1.5, 7.3 1.5, 7.3 8.2, 1.5 8.2, 1.5 1.5))"
)

result <- burn_sparse(poly, extent = c(0, 10, 0, 10), dimension = c(10, 10))
result
#> <gridburn> 10 x 10 grid, 1 geometry
#>   runs:  6 (30 interior cells)
#>   edges: 20 boundary cells
#>   sparsity: 50.0% empty

# Interior cells (weight = 1) as run-length encoded rows
result$runs

# Boundary cells with exact fractional coverage
result$edges

# Expand to dense matrix for visualisation
image(materialise_chunk(result), useRaster = TRUE)
```

## Output Format

`burn_sparse()` returns a list with two data.frames:

- **`runs`**: `(row, col_start, col_end, id)` — contiguous interior cells
  where coverage fraction ≈ 1.0, compressed by row
- **`edges`**: `(row, col, weight, id)` — boundary cells with exact
  partial coverage (0 < weight < 1)

This is far more compact than a dense matrix for typical polygon-on-grid
operations, especially when polygons are large relative to cell size.

## Design Notes

The sparse two-table format is designed for downstream use in zonal
statistics, polygon overlay analysis, and similar operations where you
need to know *which cells* a polygon covers and *by how much*, but don't
need to materialise the full grid.

`gridburn` uses [libgeos](https://github.com/paleolimbot/libgeos) for
GEOS access (no system GEOS dependency, no configure script). The
exactextract algorithm handles all geometry types (polygons,
multipolygons, lines) and correctly accounts for holes.



## Tiling

The exactextract algorithm computes a dense coverage matrix for each
polygon's bounding box, then gridburn compresses this to sparse output.
For large grids with polygons that span many cells, this intermediate
dense matrix can exceed available memory.

`burn_sparse()` handles this automatically by splitting the grid into
tiles of at most `tile_size × tile_size` cells (default 4096, capping
the dense intermediate at ~64 MB per tile). Tiling is transparent — the
output is identical to the non-tiled case, with row/column indices in
the full grid coordinate system.

```r
dsn <- "/vsizip//vsicurl/https://resources.gisdata.mn.gov/pub/gdrs/data/pub/us_mn_state_dnr/water_lake_superior_basin/shp_water_lake_superior_basin.zip"
ls_wkb <- wk::wkb(vapour::vapour_read_geometry(dsn))
lake <- ls_wkb[which.max(geos::geos_area(ls_wkb))]
ex <- as.numeric(wk::wk_bbox(ls_wkb))[c(1, 3, 2, 4)]

# 25,600 × 12,800 grid — fits in a few tiles
system.time(result <- burn_sparse(geos::as_geos_geometry(lake), ex, c(25600, 12800)))
#>    user  system elapsed
#>   5.737   3.190   8.924

str(result)
# List of 4
#  $ runs     :'data.frame':	112711 obs. of  4 variables:
#   ..$ row      : int [1:112711] 71 72 73 74 75 76 77 78 79 80 ...
#   ..$ col_start: int [1:112711] 11975 11973 11972 11971 11969 11969 11968 11968 11968 11968 ...
#   ..$ col_end  : int [1:112711] 11976 11978 11980 11982 11983 11984 11985 11985 11986 11986 ...
#   ..$ id       : int [1:112711] 1 1 1 1 1 1 1 1 1 1 ...
#  $ edges    :'data.frame':	314833 obs. of  4 variables:
#   ..$ row   : int [1:314833] 69 69 70 70 70 70 71 71 71 71 ...
#   ..$ col   : int [1:314833] 11975 11976 11974 11975 11976 11977 11972 11973 11974 11977 ...
#   ..$ weight: num [1:314833] 0.06066 0.00736 0.2445 0.90007 0.80403 ...
#   ..$ id    : int [1:314833] 1 1 1 1 1 1 1 1 1 1 ...
#  $ extent   : num [1:4] 565502 1165764 5155179 5441497
#  $ dimension: int [1:2] 25600 12800
#  - attr(*, "class")= chr "gridburn"
#  
```

(We're not entirely sparse until it's finished because each new tile is inherently materialized unnecessarily upfront, 
but that's a different design challenge for the longer term - GEOS and exactextract geared towards calculating results,
not returning intermediate strutures like these). 

Each tile is completely independent, no shared state, embarrassingly parallel. Two levels of optimization stack nicely: 
clip geometries to tile extent first (so each worker gets only the relevant subset), then parallelize across tiles. The sparse output tables just rbind at the end.
The geometry clipping is the bigger win for datasets like nc.shp where most polygons only touch a few tiles. A spatial index prefilter in R \
(geos::geos_intersects against tile rectangles) would cut that dramatically. 

```r
dsn <- "/vsizip//vsicurl/https://resources.gisdata.mn.gov/pub/gdrs/data/pub/us_mn_state_dnr/water_lake_superior_basin/shp_water_lake_superior_basin.zip"
ls_wkb <- wk::wkb(vapour::vapour_read_geometry(dsn))
lake <- ls_wkb[which.max(geos::geos_area(ls_wkb))]
ex <- as.numeric(wk::wk_bbox(ls_wkb))[c(1, 3, 2, 4)]

# 105200 x  49600 grid — without parallel
system.time(result <- burn_sparse(geos::as_geos_geometry(lake), ex, c(52600, 24800) * 2))
#   user  system elapsed 
# 92.005   2.202  94.220 

str(result)
# List of 4
#  $ runs     :'data.frame':	1519462 obs. of  4 variables:
#   ..$ row      : int [1:1519462] 269 270 271 272 273 274 275 276 277 278 ...
#   ..$ col_start: int [1:1519462] 49208 49207 49206 49204 49203 49201 49200 49199 49197 49196 ...
#   ..$ col_end  : int [1:1519462] 49211 49213 49215 49217 49219 49221 49223 49224 49226 49228 ...
#   ..$ id       : int [1:1519462] 1 1 1 1 1 1 1 1 1 1 ...
#  $ edges    :'data.frame':	1261114 obs. of  4 variables:
#   ..$ row   : int [1:1261114] 267 267 268 268 268 268 268 268 269 269 ...
#   ..$ col   : int [1:1261114] 49209 49210 49207 49208 49209 49210 49211 49212 49206 49207 ...
#   ..$ weight: num [1:1261114] 0.17634 0.13678 0.00424 0.43683 0.97089 ...
#   ..$ id    : int [1:1261114] 1 1 1 1 1 1 1 1 1 1 ...
#  $ extent   : num [1:4] 565502 1165764 5155179 5441497
#  $ dimension: int [1:2] 105200 49600
#  - attr(*, "class")= chr "gridburn"
```

Set `tile_size = Inf` to disable tiling (not recommended for large
grids). Tiles that don't overlap any geometry produce no output, so
the overhead of tiling is minimal.



## License

Apache License 2.0. The vendored exactextract code is Copyright
ISciences, LLC, also Apache 2.0.


## Code of Conduct
  
Please note that the gridburn project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/1/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.
